{"name":"Tofish","tagline":"An interactive language interpreter for Arduino Uno","body":"#Toby's Own Forth-ish for Arduino\r\n\r\nAn interactive language interpreter for the Arduino Uno. Type programs\r\non the command line just like on an 8-bit home computer from the 1980's!\r\n\r\nWorks with an Uno right out of the box and does not require messing about\r\nwith changing or overwriting bootloaders.\r\n\r\nRequires the `avra` assembler to build it and `avrdude` to download it (see below).\r\n\r\n(c) 2012 Tobias Schaer (tschaer).\r\nReleased under the \"MIT Open Source Software License\".\r\n\r\n\r\n#Quick Start Guide\r\n\r\nFirst install the avra assembler for your platform. I am using Mac so all the\r\ninstructions are given in that format but it should be easy to convert to what\r\nyou are using.\r\n\r\nBuild:\r\n\r\n    $ avra -l tofish.lst tofish.asm\r\n\r\nDownload:\r\n\r\n    $ avrdude -v -patmega328p -carduino -P/dev/tty.usbmodemfd111 -b115200 -D -Uflash:w:tofish.hex:i\r\n\r\nOnce downloaded, you are ready to try an interactive session using a serial\r\nterminal program.\r\n\r\nThe Serial Monitor on the Arduino IDE will work if you set it\r\nto 19200 baud and \"Carriage Return\" line endings. To change the settings\r\nproperly you may have to close and open the Serial Monitor window. Another\r\noption is to use a dedicated serial terminal (like ZTerm for the Mac,\r\n<http://homepage.mac.com/dalverson/zterm/> with \"destructive backspace\" turned\r\non to make the input editing look pretty). \r\n\r\nOpen your serial terminal and you should get the prompt. Type\r\n'?' to see the list of builtin commands:\r\n\r\n    tofish  >-))*>\r\n\r\n    > ?\r\n\r\n    emit sEmit .$ . CR space spaces + - negate / inc dec AND OR INV XOR LSL LSR ASR\r\n    ROL ROR dup drop swap over byteswap Rpush Rpop Rpeek R@+ R!+ =0 <0 >0 = < >\r\n    ?skip ?true ?end start stake : ; r@ r! c@ c! @ dump mem ? show list\r\n\r\n    Ok.\r\n    >\r\n\r\nYou're up and running! Let's do the Forth \"Hello World\" by adding two numbers:\r\n\r\n    > 1 1 + .\r\n    00001\r\n    Ok.\r\n    >\r\n \r\nCongrats! Your first tofish program. If you had problems with the above, for\r\nexample you got nothing in the terminal or \"unknown word\" type error messages,\r\ncheck the correct serial port is bring used, the line speed is 19200 8N1 and\r\nline endings are set for \"Carriage Return\" (0x0D) ONLY.\r\n\r\n\r\n#Background\r\n\r\nIn 1968 Chuck Moore wrote Forth on an IBM 1130. It was a self-hosted programming system that supported multiple simultaneous users, interactivity, its own high-level language and a complete development toolchain, all in a few kilo-words of core.\r\n\r\nThe 1130 Forth is described in a paper he wrote together with his colleague Geoffrey Leach (Forth: a Language for Interactive Computing, found here: http://www.forth.cz/Download/Doc/4th_1970.pdf). Tofish is inspired primarily by that paper. Chuck's unpublished book \"Programming a Problem-Oriented Language\" http://www.colorforth.com/POL.htm) and an assembly listing of FIG-Forth for the 6800 chip from 1979 (http://www.forth.org/fig-forth/fig-forth_6800.pdf) also filled in a lot of detail.\r\n\r\nTofish is not Forth. Chuck Moore wrote Forth to serve his needs and to suit his own tastes, and encouraged others to write their own Forths. Which is exactly what I did.\r\n\r\nTofish is a fun experiment in language design. It may mature into a more serious implementation, but with the capabilities it has now, it is easy to quickly write and test programs right on the Arduino.\r\n\r\n# Objective\r\n\r\nTofish is meant to be a language for hardware control. Its design goals are to have a vocabulary well suited to shuffling bits around, and to have a simple, self-hosting implementation. I want to be able to develop code right\r\n on the Arduino, without having to use any other tools.\r\n\r\n# Some Technical Stuff\r\n\r\nTofish assembles to a single Intel Hex file that goes into the first few kilowords of FLASH. It uses the existing bootloader and does not affect it in any way: in other words, a \"stock\" Arduino will remain a \"stock\" Arduino even if you install tofish on it, and you can go back to downloading sketches from the Arduino IDE once you get tired of tofish.\r\n \r\nTofish stores all program code you type in RAM. This means there is a relatively small upper limit (about 1600 bytes) on the size of your Tofish programs. There are commands to LIST the code and to SHOW its contents in human and machine-readable format, so that you can capture this output in your terminal and later \"download\" them by copying and pasting back into to the terminal window. The source code format is such that everything is 100% runnable from the command line.\r\n \r\nTofish is fully interpreted. This means it stores program code as strings in RAM, and has to re-interpret this code each time you run it.\r\n\r\nTofish doesn't have a very good math function implementation. The divide only supports 16-by-8 bit division, and there is no multiply. Numbers canget bigger than 16 bits very quickly when multiplying and I haven't spent any time on figuring out a convention for dealing with numbers that stretch across more than one stack element.\r\n\r\n#Language Crash Course\r\n\r\nThe command selection is somewhat esoteric and sometimes only distantly related to Forth. I prefer to call them commands instead of words because they are permanent and cannot be redefined. The FLASH dictionary is always searched first.\r\n\r\nCommands work in the classic, confusing Forth style: some consume arguments to the left (for example, arithmetic and logic commands), some to the right (definition and status words), and some consume none at all. There is of\r\ncourse no way of knowing any of this just by looking.\r\n\r\nNumbers are restricted to signed 16-bit integers. They are by default in base-10, but with use of a $ they can both be entered and displayed in base-16:\r\n\r\n    > $F $12 + .$\r\n    0021\r\n    Ok.\r\n    > $FF 1 + .\r\n    00256\r\n    Ok.\r\n    >\r\n\r\nNeither `.` nor `.$` has leading-zero suppression. This may get added with a global switch at some point.\r\n\r\n#Language Keywords By Function\r\n\r\nConsole:\r\n\r\n    emit    : print the top stack element as an ASCII char, eg '$41 emit' prints 'A'\r\n    sEmit   : print a string stored in FLASH given its address on the stack\r\n    .$      : print top stack element in 16-bit hexadecimal format\r\n    .       : print the top stack element in 16-bit decimal format\r\n    CR      : print a Carriage Return\r\n    space   : print a space\r\n    spaces  : print as many spaces as the top stack element, eg '5 spaces'\r\n\r\nArithmetic:\r\n\r\n    +       : signed 16-bit add of top two stack elements\r\n    -       : signed 16-bit subtraction of top two stack elements\r\n    negate  : flip the sign on the top stack element\r\n    /       : signed 16-bit integer division. No remainder is generated\r\n    inc     : increment top stack element\r\n    dec     : decrement top stack element\r\n\r\nBit manipulation:\r\n\r\n    AND     : bitwise AND of top two stack elements\r\n    OR      : bitwise OR of top two stack elements\r\n    INV     : bitwise NOT of top stack element. Note: do not use for truth values\r\n    XOR     : bitwise XOR of top two stack elements\r\n    LSL     : bitwise left shift of top stack element. Shifted bits are lost\r\n    LSR     : bitwise right shift of top stack element. Shifted bits are lost\r\n    ASR     : sign-preserving right shift of top stack element\r\n    ROL     : bitwise rotate left of top stack element\r\n    ROR     : bitwise rotate right of top stack element\r\n\r\nStack operators:\r\n\r\n    dup     : clone the top stack element\r\n    drop    : drop the top stack element\r\n    swap    : swap the top two stack elements\r\n    over    : copy the second stack element to the top\r\n    byteswap: change the endianness of the top stack element\r\n\r\nReturn stack operators:\r\n\r\n    Rpush   : move top of data stack onto the return stack\r\n    Rpop    : move top of return stack to data stack\r\n    Rpeek   : copy top of return stack to data stack\r\n    R@+     : use return stack as post-incrementing index register for memory reads\r\n    R!+     : use return stack as post-incrementing index register for memory write\r\n\r\nDetermination operators:\r\n\r\n    =0      : if top stack element is zero, replace it with a logical TRUE (0x01)\r\n    <0      : if top stack element is negative, replace it with a logical TRUE\r\n    >0      : if top stack element is positive, replace it with a logical TRUE\r\n\r\nComparison operators:\r\n\r\n    =       : if top two stack elements are equal, replace them with a logical TRUE\r\n    <       : if the second stack element is less than the first, replace with TRUE\r\n    >       : if the second stack element is greater that the first, replace w TRUE\r\n\r\nFor the above six commands, a logical FALSE (0x00) is placed on the stack if the condition is not met. In all cases the operators consume their arguments.\r\n\r\nConditional constructs:\r\n\r\n    ?skip   : if top stack element is a logical TRUE, skip the next word\r\n    ?true   : if top stack element is true, execute the words following this one,\r\n            : else skip ahead until ?end is found\r\n    ?end    : terminator for ?true\r\n\r\nLooping constructs:\r\n\r\n    start   : start the current definition again\r\n    stake   : move the start of the definition to the first word after this one\r\n\r\nDefinition:\r\n\r\n    :       : start the definition of a new word. The word right after it is the\r\n            : name of the definition. Definitions are terminated not by ; below\r\n            : but by a newline character.\r\n    ;       : same as RETURN in other languages, and can be used anywhere in a\r\n            : definition\r\n        \r\nMemory access:\r\n\r\n    r@      : fetch a 16-bit word from RAM from the address on the stack\r\n    r!      : store the top of stack to the address in the second stack element\r\n    c@      : like r@ but fetch only the lower 8 bits from RAM\r\n    c!      : like r! but store only the lower 8 bits to RAM\r\n    @       : fetch a 16-bit word from FLASH from the address on the stack\r\n\r\nVery useful:\r\n\r\n    dump    : dump 256 bytes of FLASH starting at the address on top of stack\r\n            : eg '$200 dump'\r\n    mem     : dump 256 bytes of RAM starting at the address on top of stack\r\n            : eg '$100 mem'\r\n    ?       : show all language keywords\r\n    list    : list all user-defined definitions\r\n    show    : print the definition of the word right after it\r\n            : eg 'show mydefinition'\r\n\r\n#Some Examples\r\n\r\nA simple definition session:\r\n\r\n    > : plus2 2 + ;\r\n\r\n    Ok.\r\n    > 2 plus2 .\r\n    00004\r\n    Ok.\r\n    > list\r\n    plus2\r\n\r\n    Ok.\r\n    > show plus2\r\n    : plus2 2 + ;\r\n\r\n    Ok.\r\n    >\r\n\r\nLet's turn an LED on and off. We have access to all RAM including I/O, we just have to call it by its raw hex address. Set the Data Direction Register to all outputs:\r\n\r\n    > $24 $FF r!\r\n\r\nThen we'll get the current status onto the stack:\r\n\r\n    > $25 c@ \r\n\r\nAnd turn on Bit 5:\r\n\r\n    > $20 OR\r\n\r\nAnd store it back:\r\n\r\n    > $25 swap c!\r\n\r\nYou can at any time see what's on the stack by making a copy of it and printing\r\nit out, like so:\r\n\r\n    > dup .$\r\n\r\nCombining all the commands together into one line:\r\n\r\n    > $25 dup c@ $20 OR c!\r\n\r\nWe can now make that into a definition:\r\n\r\n    > : ledOn $25 dup c@ $20 OR c! ;\r\n\r\n    Ok.\r\n    >\r\n\r\nAnd we can do the same to turn it off:\r\n\r\n    > : ledOff $25 dup c@ $DF AND c! ;\r\n  \r\n    Ok.\r\n    >\r\n\r\nTo make the LED blink we need to run these two commands in a loop, but with some kind of delay in between. So we define an empty loop:\r\n\r\n    > : delay dup =0 ?true drop ; ?end dec start\r\n  \r\n    Ok.\r\n    >\r\n\r\nThen we can put it all together in a word called blink:\r\n\r\n    > : blink ledOn 200 delay ledOff 200 delay start ;\r\n  \r\nThere is no \"break\" command. To return to the prompt you have to reset the Arduino, which unfortunately destroys your code!\r\n\r\n#More Examples\r\n\r\nDump some memory to the screen:\r\n\r\n     > : memline dup .$ space Rpush $8 stake R@+ byteswap .$ space dec dup =0 ?true\r\n         CR drop Rpop ; ?end start\r\n\r\n     Ok.\r\n     > $200 memline\r\n     0200 4C0C 007B 7B5F FA73 EFA4 6EC6 BDFA CD9F\r\n\r\n     Ok.\r\n\r\nCompare this to the real memory dump routine:\r\n\r\n     > $200 mem\r\n     0200 4C 0C 00 7B 7B 5F FA 73 EF A4 6E C6 BD FA CD 9F  L..{{_.s..n.....\r\n     0210 36 3B EB F6 CD BD E7 7E 9E 07 B6 E6 FA 3B 02 00  6;.....~.....;..\r\n     0220 3F 1F B3 FF EC 6C E1 CD 7B FF 72 F7 E8 FF E3 43  ?....l..{.r....C\r\n     0230 D3 57 D8 C1 FD 9E 5D 37 BF 37 B6 72 DB C3 FD AF  .W....]7.7.r....\r\n     0240 D7 F0 7B DC 4D AB C5 D1 CC 07 33 7F E6 FE AB 3D  ..{.M.....3...=\r\n     0250 15 7E 7A F5 E7 6B 0F 93 76 BF EA 55 77 7F 4D EE  .~z..k..v..UwM.\r\n     0260 D9 84 47 FB AD FD 34 EB BC 8C 39 F2 B4 7D FB DF  ..G...4...9..}..\r\n     0270 C5 EB 7D 5F 3D FC 6F 8F F9 5B 5D D5 DE CC 2F 9A  ..}_=.o..[].../.\r\n     0280 E7 C5 FF C4 F7 7D 77 D3 E7 FF FF A3 A7 AF CD 5E  .....}w........^\r\n     0290 FE B9 EF C1 E7 8E B9 4E 56 79 FF 9F EE B3 5E EE  .......NVy....^.\r\n     02A0 22 73 71 F1 C8 FD C1 94 7D FD CB E2 7B FD 7D 77  \"sq.....}...{.}w\r\n     02B0 DF FB EE FE A5 AF D6 44 BE 59 45 CB 76 FF EA F6  .......D.YE.v...\r\n     02C0 D7 9B F5 3A 4D E3 E3 4F DE D3 97 CA BE 8F D5 EB  ...:M..O........\r\n     02D0 6F FF E6 FA DF DB AB 2C 67 9D 67 47 FF 67 BB F7  o......,g.gG.g..\r\n     02E0 2B E9 4A 4E F5 79 6B D2 AB 69 BB AC AE D5 C5 BA  +.JN.yk..i......\r\n     02F0 47 6F 3A F8 B6 2D 75 D8 08 68 C6 AB E6 7F 29 B8  Go:..-u..h...).\r\n \r\n     Ok.\r\n     >\r\n\r\nThe same goes for FLASH:\r\n\r\n     > $00 dump\r\n     0000 0C94 3400 FFFF FFFF FFFF FFFF FFFF FFFF  ..4.............\r\n     0008 FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF  ................\r\n     0010 FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF  ................\r\n     0018 FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF  ................\r\n     0020 FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF  ................\r\n     0028 FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF  ................\r\n     0030 FFFF FFFF FFFF FFFF 10E0 1093 C500 17E6  ................\r\n     0038 1093 C400 18E1 1093 C100 16E0 1093 C200  ................\r\n     0040 18E0 1093 5E00 1FEF 1093 5D00 D2E0 C0E2  ....^.....].....\r\n     0048 D093 0301 C093 0201 10E0 00E0 1093 0501  ................\r\n     0050 0093 0401 11E0 06E0 5801 11E0 1093 0101  ........X.......\r\n     0058 1093 0001 F1E0 E6E9 0C94 6400 0A93 1A93  ..........d.....\r\n     0060 0E94 7400 0E94 A000 6F01 1091 0101 1123  ..t.....o......#\r\n     0068 29F0 0E94 8705 A591 B491 04C0 0E94 8B05  )...............\r\n     0070 A191 B081 FD01 0994 FC01 D501 1091 0001  ................\r\n     0078 1123 69F0 1591 1032 E9F3 1030 39F0 1D93  .#i....2...09...\r\n\r\n     Ok.\r\n     >\r\n\r\nAll other questions can be answered by writing to me (toby dot schaer at gmail dot com) or looking in the source code. Good luck!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}